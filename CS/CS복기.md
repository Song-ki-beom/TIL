# CS 복기 (2025.01.19)

 ![header](https://capsule-render.vercel.app/api?color=gradient&type=waving)

### 절차적 프로그래밍 VS 객체지향 차이점

코딩하는 방식과 방법론의 차이다.

**절차적 프로그래밍(Procedural Programming)** 은 프로시져(함수)를 중점으로 사용하여 데이터 위주의 구조/로직을 설계하는 방법

**객체지향 프로그래밍** 데이터와 기능(메서드)들을 묶어 하나의 객체로 생성하여 객체간의 상호작용을 이용하여 구현

<br>
<br>


### 드로우콜

**드로우 콜(Draw Call):** CPU가 현재 프레임에 어떤 것을 그려야 할지 정하고, GPU에 오브젝트를 그리는 것을 지시하기 위해 호출하는 명령
<br>
<br>
게임의 오브젝트를 화면에 렌더링하려면 오브젝트가 렌더링 대상인지 판단하는 **컬링**을 거치며, 컬링을 거친 오브젝트가 렌더링 되기 위해선 CPU에서 GPU에게 메시(점,폴리곤,UV Map), 텍스처, 쉐이더, 트랜스폼 등의 정보를 줘야 한다.

이러한 정보들을 **렌더 상태(Render States)** 라는 테이블에 담고 각각의 요소는 GPU 메모리를 가리키는 포인터를 저장함

렌더 상태를 변경하면 최종적으로 GPU에 메시를 그리라는 명령을 보내는데, 이 명령을 **Draw Primitive Call(DP Call)**이라고 부른다.

드로우 콜에서 사용되는 명령들은 모두 GPU가 알아들을 수 있는 명령들로 변환되어야 하는데, 이것은 CPU 오버헤드를 발생시키기 때문에 드로우 콜은 CPU 병목의 원인이다.

(메시의 개수+머터리얼) X 오브젝트 개수의 횟수로 드로우 콜이 호출되며, 유니티에서는 Batch 라는 용어를 사용한다. 

<br>
<br>

### 인터페이스 VS 추상 클래스

추상 클래스와 인터페이스는 객체지향 프로그래밍에서 클래스의 구조와 동작을 정의하지만,
각각 사용하는 방식과 목적에 차이가 있다.

**추상 클래스:** 하나 이상의 추상 메서드(구현이 없는 메서드)를 포함하는 클래스이다.
직접 인스턴스화할 수 없으며, 이를 상속받은 하위 클래스에서 추상 메서드를 구현해야 합니다.

인터페이스와 달리 일반 메서드와 추상 메서드를 모두 가질 수 있다.

멤머 변수를 정의하고 값을 저장할 수 있다.

하나의 클래스만 상속받을 수 있다.

접근 제어자는 private, protected, public 접근 제어자를 사용할 수 있다.


**인터페이스:** 메서드만 정의하고, 구현을 포함하지 않는(순수 가상함수) 추상적인 틀이다.

클래스가 인터페이스를 Implement 하면, 인터페이스에 정의된 모든 메서드를 반드시 구현해야 한다.

인터페이스 자체는 메서드의 구현을 가질 수 없으며, 추상 클래스와 달리 인터페이스는 여러 개의 인터페이스를 구현할 수 있다.

하위 클래스에 설계에 대한 가이드라인을 주는 클래스이며, 해당 가이드라인은 


그리하여, 추상 클래스와 인터페이스의 차이 및 공통점을 종합해보면,
1. 추상 클래스는 클래스의 멤버함수의 Body(몸체)를 정의할 수 있다.
2. 인터페이스는 순수 가상 함수로만 정의해야한다. 
3. 공통점은 둘다 객체화 할수 없다는 것 

### 구조체와 클래스

**C++** 에서는 구조체와 클래스는 접근제어자의 기본 디폴트 상태의 차이만 있다.
(구조체는 Public , 클래스는 Private)


반면, **C#** 에서는 구조체는 값 타입(Value)으로 스택 메모리에 생성
되며, 클래스는 참조 타입(reference)으로 힙 메모리에 생성된다. 

구조체는 생성자 선언이 가능하나, 파라미터(매개변수)가 반드시 있어야 하며, 상속이 불가능하다.
필드에 선언할 시 반드시; cosnt 또는 static 을 추가해야 초기화가 가능하다.
구조체는 클래스와 달리 new 연산자 없이도 객체를 만들 수 있다.
<br>
<br>

### C# 박싱과 언박싱

**Boxing**은 값 형식의 데이터를 참조 형식으로 변환하는 작업
값 타입의 변수를 Object 타입의 변수에 할당하여 힙에 저장될 때 박싱이 발생한다.
기존에 저장된 Stack 영역에서 Heap 영역에 값 형식을 저장

**UnBoxing**참조 타입의 객체를 다시 값 타입의 데이터로 변환하는 작업 
이며, 명시적으로 캐스트를 사용하여 타입을 지정해주어야 한다.

<br>
<br>

### C#과 C++ 의 차이점

메모리 관리 방식에 가장 큰 차이점을 두고 있다(가비지 컬렉터 유무)

C#은 가비지 컬렉터가 메모리 관리를 자동으로 처리한다. GC는 메모리를 주기적으로 검사하여 더 이상 참조되지 않는 객체를 찾아서
메모리를 해제한다. 주기적으로 실행되는 과정에서 일부 프로그램의 성능이 저하되고 오버헤드가 발생할 수 있다.

C++은 개발자가 직접 메모리를 관리해야 하며, 객체를 생성할 때 'new' 연산자를 사용하고, 사용이 끝나면 
'delete' 를 통해 메모리를 해제한다. 수동으로 관리하기 때문에 오버헤드가 없고, 메모리 할당과 해제의 속도가 빠르다.


### CPU MMU 

MMU(Memory Management Unit, 메모리 관리 장치)는 CPU와 메모리(RAM) 사이에서
가상 주소를 실제 메모리 주소로 변환해준다.

변환 과정은 주로 페이지 테이블(Page Table)을 사용해 관리된다.

변환 속도를 높이기 위해선 자주 참조되는 가상 주소-실제 주소 정보를 
TLB(Translation Lookaside Buffer)에 저장한다.

TLB에 Hit되면 TLB에 저장된 실제 주소를 참조, Miss 하면 Page Table을 조회하여 변환 정보를 가져옴 


### Unity 코루틴 

coroutine은 실행을 일시정지하고 제어권을 유니티의 프레임 루프에 넘겼다가
다음 프레임에 정지했던 지점부터 다시 코드를 실행할 수 있는 메소드입니다.

일반 함수와는 달리 실행 중간에 멈출 수 있다는 점이 장점이다.

Unit에서 코루틴은 Unity의 메인 스레드에서 실행된다. 
코루틴은 Unity 엔진의 프레임 루프와 결합되어, 특정 조건이나 시간 동안 대기한 후
다시 실행된다. 이는 Unity가 단일 스레드로 동작하면서도 비동기적 작업을 처리할 수 있도록
설계된 방식이다.

IEnumerator 과 yield return

**IEnumerator** 은 코루틴의 반환형으로 사용되며 , 내부적으로 Iterator 패턴을 사용하여
실행 상태를 관리
코루틴이 중단될 시점(Yield)과 실행 상태를 기억함

Unity에서 IEnumerator는 Unity 의 MonoBehaviour와 결합되어 프레임 단위로 실행된다.

**yield return**

은 코루틴 실행을 멈추고 제어권을 Unity에 반환한다.

반환값에 따라 대기 조건을 지정

yield return null: 다음 프레임까지 대기.

yield return new WaitForSeconds(x): x초 동안 대기.

yield return StartCoroutine(다른 코루틴 함수()): 다른 코루틴이 완료될때까지 대기함



###프로세스 vs 스레드

**프로세스:** 운영체제로부터 자원을 할당받은 작업의 단위(작업 중인 프로그램)

메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태

**스레드:** 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위 

하나의 프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위

멀티 스레드로 실행되는 프로그램의 경우, 스레드는 고유의 스택만 할당받고, 
나머지 힙, 코드, 데이터는 공유된다.





















