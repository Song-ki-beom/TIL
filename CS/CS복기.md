# CS 복기 (2025.01.19)

 ![header](https://capsule-render.vercel.app/api?color=gradient&type=waving)

### 절차적 프로그래밍 VS 객체지향 차이점

코딩하는 방식과 방법론의 차이다.

**절차적 프로그래밍(Procedural Programming)** 은 프로시져(함수)를 중점으로 사용하여 데이터 위주의 구조/로직을 설계하는 방법

**객체지향 프로그래밍** 데이터와 기능(메서드)들을 묶어 하나의 객체로 생성하여 객체간의 상호작용을 이용하여 구현

<br>
<br>


### 드로우콜

**드로우 콜(Draw Call):** CPU가 현재 프레임에 어떤 것을 그려야 할지 정하고, GPU에 오브젝트를 그리는 것을 지시하기 위해 호출하는 명령
<br>
<br>
게임의 오브젝트를 화면에 렌더링하려면 오브젝트가 렌더링 대상인지 판단하는 **컬링**을 거치며, 컬링을 거친 오브젝트가 렌더링 되기 위해선 CPU에서 GPU에게 메시(점,폴리곤,UV Map), 텍스처, 쉐이더, 트랜스폼 등의 정보를 줘야 한다.

이러한 정보들을 **렌더 상태(Render States)** 라는 테이블에 담고 각각의 요소는 GPU 메모리를 가리키는 포인터를 저장함

렌더 상태를 변경하면 최종적으로 GPU에 메시를 그리라는 명령을 보내는데, 이 명령을 **Draw Primitive Call(DP Call)**이라고 부른다.

드로우 콜에서 사용되는 명령들은 모두 GPU가 알아들을 수 있는 명령들로 변환되어야 하는데, 이것은 CPU 오버헤드를 발생시키기 때문에 드로우 콜은 CPU 병목의 원인이다.

(메시의 개수+머터리얼) X 오브젝트 개수의 횟수로 드로우 콜이 호출되며, 유니티에서는 Batch 라는 용어를 사용한다. 

<br>
<br>

### 인터페이스 VS 추상 클래스

추상 클래스와 인터페이스는 객체지향 프로그래밍에서 클래스의 구조와 동작을 정의하지만,
각각 사용하는 방식과 목적에 차이가 있다.

**추상 클래스:** 하나 이상의 추상 메서드(구현이 없는 메서드)를 포함하는 클래스이다.
직접 인스턴스화할 수 없으며, 이를 상속받은 하위 클래스에서 추상 메서드를 구현해야 합니다.

인터페이스와 달리 일반 메서드와 추상 메서드를 모두 가질 수 있다.

멤머 변수를 정의하고 값을 저장할 수 있다.

하나의 클래스만 상속받을 수 있다.

접근 제어자는 private, protected, public 접근 제어자를 사용할 수 있다.


**인터페이스:** 메서드만 정의하고, 구현을 포함하지 않는(순수 가상함수) 추상적인 틀이다.

클래스가 인터페이스를 Implement 하면, 인터페이스에 정의된 모든 메서드를 반드시 구현해야 한다.

인터페이스 자체는 메서드의 구현을 가질 수 없으며, 추상 클래스와 달리 인터페이스는 여러 개의 인터페이스를 구현할 수 있다.

하위 클래스에 설계에 대한 가이드라인을 주는 클래스이며, 해당 가이드라인은 


그리하여, 추상 클래스와 인터페이스의 차이 및 공통점을 종합해보면,
1. 추상 클래스는 클래스의 멤버함수의 Body(몸체)를 정의할 수 있다.
2. 인터페이스는 순수 가상 함수로만 정의해야한다. 
3. 공통점은 둘다 객체화 할수 없다는 것 

**구조체와 클래스**

**C++** 에서는 구조체와 클래스는 접근제어자의 기본 디폴트 상태의 차이만 있다.
(구조체는 Public , 클래스는 Private)


반면, **C#** 에서는 구조체는 값 타입(Value)으로 스택 메모리에 생성
되며, 클래스는 참조 타입(reference)으로 힙 메모리에 생성된다. 

구조체는 생성자 선언이 가능하나, 파라미터(매개변수)가 반드시 있어야 하며, 상속이 불가능하다.
필드에 선언할 시 반드시; cosnt 또는 static 을 추가해야 초기화가 가능하다.
구조체는 클래스와 달리 new 연산자 없이도 객체를 만들 수 있다.













