<h1>스마트 포인터</h1>

 ![header](https://capsule-render.vercel.app/api?color=gradient&type=waving)

### 스마트 포인터

스마트 포인터는 C++의 직접적인 메모리 참조로 인해 발생하는 댕글링 포인터 혹은 메모리 누수, 오염을 방지하기 위해 지원되는 포인터이다. 

**댕글링 포인터란?:** 해제된 메모리 영역을 계속 가리키고 있는 포인터를 댕글링 포인터라고 한다.

다음 코드와 디버깅을 통해 댕글링 포인터가 발생하는 상황을 알아보자.

<br>
<br>
<br>
<br>


![LocalVariableImage](/Images/SmartPointer1.png)  

위 스샷의 class Knight 은 다른 Knight 을 _target 변수로 참조하여 Attack() 함수를 호출할 시 타겟으로 잡은 Knight에 공격을 가한다.

![LocalVariableImage](/Images/SmartPointer2.png)  


main 함수에는 k1 , k2 두개의 Knight 을 new 키워드를 통해 동적할당하고, k1 이 target 을 k2로 가리키는 코드 이후 

<code>
delete k2;
</code>

<br>
delete 연산을 통해 동적할당된 k2의 메모리를 해제하고 나면,
k1->_target 은 해제된 범위의 메모리를 가리키게 된다.  <b>운영체제에 반환되는 메모리에는 반환되기 전의 값과 같은 값이 포함된다는 것을 명심하자.</b> 

<br>
<br>

<U>delete 연산자 자체는 아무것도 삭제하지 않는다.</U> 단순히 가리키는 메모리를 OS에 반환하고, 해당 메모리 영역을 다른 응용 프로그램에 다시 할당할 수 있다.

<br>

삭제된 k2 포인터는 여전히 Knght 객체 크기의 범위를 가리키며, 다른 변수와 마찬가지로 새 값을 할당받을 수 있다.

![LocalVariableImage](/Images/SmartPointer3.png)  
(해제되기 전 k2의 메모리)

<br>
<br>

![LocalVariableImage](/Images/SmartPointer4.png)  
(해제되고 난 후의 k2 메모리, dddddd로 초기화된다.)

<br>
<br>

![LocalVariableImage](/Images/SmartPointer5.png)  
![LocalVariableImage](/Images/SmartPointer6.png)  

(Knight* k1이 가리키는 객체에서의 Attack 함수 실행 부분, _target은 해제되었지만 여전히 참조하고 있는 상태이므로, 해당 영역에 -=damage , 즉 10을 빼는 연산을 진행해버려 메모리가 오염된 모습을 확인 할수 있다.)

<br>
<br>
<br>

위 스샷의 메모리 영역에서 본래 k2 가 가리키던 메모리 영역에 할당해제된 값 dddddddd 은 10을 뺀  ddddddd3 으로 결과가 오염되어버렸으며, <b>해당 메모리 영역을 다른 객체나 변수가 할당받아 사용되고 있을 경우에는 의도치 않은 곳에 값을 변경시켜버리는, 매우매우 위험한 상황을 야기할 수 있다.</b>

<br>
<br>

이렇게 Raw Pointer 을 사용할 경우에는, 이러한 댕글링 포인터의 문제를 해결할 수 있는 방안이 없다.

그리하여, 우리는 **스마트 포인터**를 통해 간접적으로 참조할 수 있어야 한다.



**Shared_ptr**: 참조 대상(객체)이 더 이상 어떤 포인터에게도 참조되지 않을 때 , 자동으로 알아서 delete 를 수행, 이는 ref Count 방식으로 동작된다.




