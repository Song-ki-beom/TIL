<h1>포인터</h1>

 ![header](https://capsule-render.vercel.app/api?color=gradient&type=waving)

### 포인터 

프로그램이 변수를 인스턴스화 할 때 사용 가능한 메모리 주소가 변수에 자동으로 할당된다.
이 때 변수에 할당된 값은 이 메모리 주소에 저장된다.

<pre>
<code>

int x = 2; // 사용 가능한 메모리 주소가 x 변수에 자동으로 할당되고, 2라는 값은 이 메모리 주소에 저장됨 

</code>
</pre>

즉, 변수를 선언하면 CPU가 RAM의 위에 별도의 메모리 조각을 할당하고 위치를 반환하며,
다음부터는 해당 변수에 접근하기 위해 항상 해당 변수가 저장된 메모리 주소를 찾아 접근해야한다는 뜻이다. 



포인터를 배우기 전에 일단 주소 연산자에 대해서 알아보자
<br>
<br>
<br>

### 주소 연산자 (&) 

주소 연산자 &를 사용하면 변수에 할당된 메모리 주소를 확인할 수 있다.

<pre>
<code>

	//참조 : 데이터가 저장된 주소값을 가리키는 것

	int* ptr= &num; // *가 붙는 순간 해당 ptr 변수에는 아키텍쳐에 따라 4바이트 OR 8바이트 크기로 num 변수의 주소가 저장됨


</code>
</pre>

위 코드와 같이 num 변수의 주소를 반환하기 위해 & 연산자를 num왼쪽에 추가하고, 해당 주소값을 저장하기 위한 변수로 **포인터**를 사용한다.


### 포인터 (*)


포인터 선언 방법
<pre>
<code>
    Type* 변수이름;

</code>
</pre>

포인터는 변수나 데이터가 저장된 메모리의 위치를 저장 혹은 가리키는 변수이다. 주소를 저장하는 바구니라 생각하면 쉬우며, x86 , x64 아키텍쳐에 따라 포인터라는 바구니는 4바이트(32비트) or  8바이트(64비트) 고정 크기로 저장된다.

해당 변수가 포인터 변수임을 변수 이름 왼쪽에 *을 붙여서 표시하며,

Type을 명시하는 이유는, 포인터가 저장된 메모리 주소를 접근하고 나서, 해당 메모리에 저장된 값의 타입을 알려줘야 하기 때문에 별도로 지정해둔다. 

해당 타입을 제대로 지정해두지 않으면 잘못된 범위의 값을 참조하거나 변경하게 되는 참사가 발생할 수 있다.


Visual Studio 의 디버깅 모드에서 포인터의 개념이 어떻게 구현되는지 확인해보자.

![LocalVariableImage](/Images/Pointer1.png) 

![LocalVariableImage](/Images/Pointer2.png) 
<br>

0x00b7f704 라는 위치에 1 값이 저장된 num이 있으며, 해당 위치값을 int 형 포인터 ptr 변수에 저장해보면 
<br>
<br>

![LocalVariableImage](/Images/Pointer3.png) 
<br>
<br>

ptr 값에 0x00b7f704, 즉 num의 메모리 주소값이 저장됨을 확인 할 수 있다.

x86 아키텍쳐에서 빌드했으므로 주소값은 항상 4바이트의 형태로 고정되어 저장된다. x64 아키텍쳐에서 구동될 경우에는 고정 8바이트가 저장됨을 유추할 수 있다.

<br>
<br>

### 역참조 (*) 

포인터를 이용해서 방법에는 여러가지가 있는데, 일단 **역참조 연산자**를 통해 포인터가 가리키는 주소의 값을 가져오거나 수정할 수 있다.

![LocalVariableImage](/Images/Pointer4.png) 

위 스샷을 보면, value1에 ptr 전방에 * 연산자를 붙여 ptr이 가리키는 주소에 저장된 값을 가져올 수 있다. 

앞서 ptr이 참조하던 num 변수에 저장된 값 1이므로 1을 반환하여 value1 변수에 저장되는 것을 확인 할 수 있으며, ptr 은 int* 형이므로 num 변수가 담긴 메모리 주소에서 4바이트 크기의 메모리에 담긴 값을 올바르게 가져올 수 있음을 알 수 있다.
<br>
<br>

![LocalVariableImage](/Images/Pointer5.png) 
<br>

역참조 연산자를 통해 직접 주소가 가리키는 값에 접근하여 값을 수정할 수 있으며, 위와 같이 *ptr = num 에 값을 2로 수정하면 0x00CFF93C (num 메모리 주소) 에 값이 메모리 디버그 창에서 바뀌었음을 확인 할 수 있다.

<br>
<br>
<br>
<br>
<br>

포인터와 주소 연산자, 역참조 연산이 어떻게 진행되는지를 디스어셈블러로 확인해보자.

![LocalVariableImage](/Images/Pointer6.png) 

int num = 1 과 달리 포인터 할당에서는

<code>
lea  eax, [num]
</code>
<br>
<br>

명령어를 통해 num 값이 담긴 메모리의 주소값 
을 eax 레지스터에 복사하고,

<code>
mov  dword ptr [ptr], eax 
</code>
<br>
<br>

명령어를 통해 주소값을 ptr 포인터 변수에 저장하는, 한단계 거쳐 주소값을 저장하는 형태를 지닌다.

![LocalVariableImage](/Images/Pointer7.png) 

역참조를 사용하는 명령어의 경우에도,
ptr 자체로는 주소이므로 dword ptr[] 을 통해 ptr 안에 담긴 값 (num의 주소)를 eax 레지스터에 옮긴 다음, 

<br>
<br>

eax 레지스터에도 dword ptr[] 를 통해 num 에 담긴 값 1을 ecx 레지스터에 넣고,
최종적으로 value1 변수가 스택에 할당된 메모리에 ecx 레지스터의 값을 넣느 것으로 역참조 할당 연산이 이루어지는 것을 알 수 있다.