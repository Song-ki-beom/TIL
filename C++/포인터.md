<h1>포인터</h1>

 ![header](https://capsule-render.vercel.app/api?color=gradient&type=waving)

### 포인터 

프로그램이 변수를 인스턴스화 할 때 사용 가능한 메모리 주소가 변수에 자동으로 할당된다.
이 때 변수에 할당된 값은 이 메모리 주소에 저장된다.

<pre>
<code>

int x = 2; // 사용 가능한 메모리 주소가 x 변수에 자동으로 할당되고, 2라는 값은 이 메모리 주소에 저장됨 

</code>
</pre>

즉, 변수를 선언하면 CPU가 RAM의 위에 별도의 메모리 조각을 할당하고 위치를 반환하며,
다음부터는 해당 변수에 접근하기 위해 항상 해당 변수가 저장된 메모리 주소를 찾아 접근해야한다는 뜻이다. 



포인터를 배우기 전에 일단 주소 연산자에 대해서 알아보자
<br>
<br>
<br>

### 주소 연산자 (&) 

주소 연산자 &를 사용하면 변수에 할당된 메모리 주소를 확인할 수 있다.

<pre>
<code>

	//참조 : 데이터가 저장된 주소값을 가리키는 것

	int* ptr= &num; // *가 붙는 순간 해당 ptr 변수에는 아키텍쳐에 따라 4바이트 OR 8바이트 크기로 num 변수의 주소가 저장됨


</code>
</pre>

위 코드와 같이 num 변수의 주소를 반환하기 위해 & 연산자를 num왼쪽에 추가하고, 해당 주소값을 저장하기 위한 변수로 **포인터**를 사용한다.


### 포인터 (*)


포인터 선언 방법
<pre>
<code>
    Type* 변수이름;

</code>
</pre>

포인터는 변수나 데이터가 저장된 메모리의 위치를 저장 혹은 가리키는 변수이다. 주소를 저장하는 바구니라 생각하면 쉬우며, x86 , x64 아키텍쳐에 따라 포인터라는 바구니는 4바이트(32비트) or  8바이트(64비트) 고정 크기로 저장된다.

해당 변수가 포인터 변수임을 변수 이름 왼쪽에 *을 붙여서 표시하며,

Type을 명시하는 이유는, 포인터가 저장된 메모리 주소를 접근하고 나서, 해당 메모리에 저장된 값의 타입을 알려줘야 하기 때문에 별도로 지정해둔다. 

해당 타입을 제대로 지정해두지 않으면 잘못된 범위의 값을 참조하거나 변경하게 되는 참사가 발생할 수 있다.


Visual Studio 의 디버깅 모드에서 포인터의 개념이 어떻게 구현되는지 확인해보자.

![LocalVariableImage](/Images/Pointer1.png) 

![LocalVariableImage](/Images/Pointer2.png) 
<br>

0x00b7f704 라는 위치에 1 값이 저장된 num이 있으며, 해당 위치값을 int 형 포인터 ptr 변수에 저장해보면 
<br>
<br>

![LocalVariableImage](/Images/Pointer3.png) 
<br>
<br>

ptr 값에 0x00b7f704, 즉 num의 메모리 주소값이 저장됨을 확인 할 수 있다.



