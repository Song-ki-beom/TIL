<h1>포인터 연산자</h1>

 ![header](https://capsule-render.vercel.app/api?color=gradient&type=waving)

### 포인터 연산

포인터의 연산자에는 주소 연산자 , 간접 연산자 말고도 여러가지 산술 기능을 제공해주는 연산자가 있다. 

* 주소 연산자 (&) - 해당 변수의 주소를 반환하며, 명시한 변수 Type에 따라 타입의 힌트를 제공하는 포인터(Type*)를 제공한다.

* 산술 연산자 (+ -) - 포인터에 대하여 숫자를 이용한 증감을 통해 직접 접근할 주소 위치를 변경할 수 있다.
* 간접 연산자 
* 간접 멤버 연산자


주소 연산자와 간접 연산자는 다루었으니, 포인터를 심화하는 개념으로 산술 연산자와 간접 멤버 연산자에 대해서 다루도록 하자.

### 산술 연산자 (+,-) 

<pre>
<code>
TYPE* 변수이름
</code>
</pre>

포인터의 선언 부분을 살펴보면, TYPE 형은 
저장된 주소에 접근한 후 해당 변수의 메모리에 저장된 데이터의 타입(TYPE)이 무었인지 알려준다.

포인터 변수에 대해서도 일반 변수와 같이  증감 연산, 산술 연산이 적용 가능하며,

<pre>
<code>
num = 1;
int* ptr = &num;

//산술 연산, 증감 연산 모두 적용 가능
ptr = ptr +1;
ptr++;
++ptr; 
ptr +=1;
</code>
</pre>

이 때의 연산은 일반 변수에 대한 산술 연산과 달리 TYPE 크기 단위로 연산이 이루어진다.

아래 디버깅 과정을 통해 확인해보자.

![LocalVariableImage](/Images/Pointer8.png) 

해당 코드는 num이라는 멤버변수에 1을 할당하고, 일반 변수에 += 연산을 통해 1을 증가시켜 num= 2 로 만든 다음에, num 의 주소를 참조하고 있는 ptr의 주소 참조값을 다음 int 가 담긴 주소로 변경하여 저장하는 코드이다.

![LocalVariableImage](/Images/Pointer9.png) 


ptr = ptr+1 이라는 평가가 실행되기 전 디버깅 모드의 조사식에서 확인해보면 ptr 값에 &num 이 저장됨을 확인할 수 있다.

![LocalVariableImage](/Images/Pointer10.png) 

ptr = ptr+1 평가식이 실행된 이후를 살펴보면 ptr 값에 +1 이 되는것이 아닌, 실제로는 +4 가 되어 0X0075f898 -> 0x0075f89c 가 저장되어 있음을 확인할 수 있다.

이렇게 결과가 나오는 이유는 ptr 의 타입이 int* 이므로 , int 는 4byte, 주소의 +1은 1byte 단위이므로 기존의 주소에 +4가 된다는 것이다. 

즉 현재 주소에서 다음 or 전의 int 형 바구니의 위치로 이동하고 싶다는 뜻을 의미한다. (**바구니 단위의 이동**)


ptr에 1이 아닌 2를 더하는 것으로 디스어셈블러에서 확인해보자.

![LocalVariableImage](/Images/Pointer11.png) 

위 스샷을 확인해보면, eax 레지스터에 ptr 값을 넣고, +2를 add 하는 것이 아닌 2*(int형의 크기 4byte 의 주소 이동 단위 4)를 곱하여 8의 크기로 주소를 이동하는 것을 알 수 있다.



