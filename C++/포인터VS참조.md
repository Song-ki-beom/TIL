<h1>포인터 VS 참조</h1>

 ![header](https://capsule-render.vercel.app/api?color=gradient&type=waving)

## 편의성 관련 차이 
포인터와 참조형 변수는 내부적으로 구현이 같으며,
변수를 이용한 데이터의 조작 편의성 면에서는 참조형 변수가 더 사용이 용이하다.

하지만 포인터는 주소를 넘기거나 확실하게 원본을 넘는다는 힌트를 줄 수 있는데,
참조는 문법이 일반 변수를 취급하는 것과 동일하므로 코드의 가독성 면에서 오히려 마이너스가 될 수 있다.
이유는 원본의 접근 및 조작에 있어 변경을 조심해야하는 부분이 있는데도 불구하고 일반 변수처럼 취급하다보면 부득이하게 값을 변경하게 되는 경우가 생기기 때문이다.

이를 방지하기 위해 참조형 변수로 함수의 매개변수를 받을 때는, 변경을 막고 참조만 하겠다는 의미로 **const** 를 붙여 방지할 수 있다.

참고로 포인터도 **const**를 사용할 수 있으며,  * 기준으로 const 를 앞에 붙이느냐, 뒤에 붙이느냐에 따라 의미가 달라진다.

![LocalVariableImage](/Images/PointerVersusRef1.png) 

포인터 (StatInfo*) 뒤에 붙여지는 const 를 매개변수로 받아올 경우, 해당 포인터의 주소값을 바뀌지 못하게 const로 막는다는 의미가 되며, 위 스샷과 같이 전역 포인터 globalinfo 의 주소값을 할당하는것에 있어 컴파일 에러가 발생하는 것을 확인할 수 있다.

![LocalVariableImage](/Images/PointerVersusRef2.png) 

반면 포인터 앞에 붙여지는 const의 경우에는, 포인터가 가리키는 메모리의 내용을 바꾸지 못하게 막는 것으로 이해할 수 있으며, 위 스샷에서 확인할 수 있듯이 StatInfo 구조체의 값을 바꾸려고 시도하면 컴파일러가 에러를 발생시키는 것을 확인할 수 있다.


<br>
<br>
<br>
##  초기화 여부

참조형 타입은 변수의 별칭이므로, 별칭으로 사용할 대상 변수(원본)을 지정해주지 않으면 사용할 수 없다.

![LocalVariableImage](/Images/PointerVersusRef3.png) 

위 스샷을 보면 참조형 타입으로 선언된 reference 변수는 이니셜라이저(초기값)이 필요하다며 컴파일러 에러를 발생시킨다.

반면 포인터는 아무것도 참조하지 않는 상태 (nullptr or NULL) 여도 자체적으로 포인터의 선언이 가능하고 사용이 가능하다.

참조값은 Nullptr 의 개념이 없어 없는 값을 표현할때 표현에 있어 문제를 발생시킨다.

